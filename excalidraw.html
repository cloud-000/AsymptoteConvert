<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body style="display: flex; flex-direction: column;">
<input id="bruh">
<canvas id="canvas" width="1000" height="1000"></canvas>
<script>

function polygon(context, color, width, linePoints, dx, dy, offset, canvas_unit) {
    context.fillStyle = color;
    context.strokeStyle = color;
    context.beginPath();
    context.moveTo((linePoints[0][0]+ dx +offset[0])*canvas_unit, (linePoints[0][1]+dy+offset[1])*canvas_unit)
    for (let i = 1; i < linePoints.length; ++i) {
        context.lineTo((linePoints[i][0] + dx + offset[0])*canvas_unit, (linePoints[i][1] + dy + offset[1])*canvas_unit)
    }
    if (width > 0) {
        context.lineTo((linePoints[0][0] + dx + offset[0])*canvas_unit, (linePoints[0][1] + dy + offset[1])*canvas_unit)
        context.lineWidth = width;
        context.stroke();
    } else {
        context.fill();
    }
}

function toFixed(num, fixed) {
    fixed = fixed || 0;
    fixed = Math.pow(10, fixed);
    return Math.floor(num * fixed) / fixed;
}

function hexToRgb(hex, normalize=true) {
    // Remove leading '#' if present
    hex = hex.toString().replace(/^#/, '');

    // Handle shorthand hex (e.g., #fff)
    if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
    }

    const num = parseInt(hex, 16);
    let r = (num >> 16) & 255;
    let g = (num >> 8) & 255;
    let b = num & 255;
    if (normalize) {
        r = toFixed(r/255, 2)
        g = toFixed(g/255, 2)
        b = toFixed(b/255, 2)
    }

    return `rgb(${r}, ${g}, ${b})`
}

function rotate(radians, cx, cy, x, y, yIsUp=1) {
    let dx = x - cx 
    let dy = y - cy
    let cos = Math.cos(radians)
    let sin = Math.sin(radians)
    return [cx + dx * cos - dy * sin, cy + yIsUp * (dx * sin + dy * cos)]
}

class ExcalidrawToAsy {
    constructor() {
        this.elements = []
        this.dummy = null
        this.types = {}
        this.text = ""
    }

    init() {
        this.addType("rectangle", (e) => {
            this.default(e)
            console.log(this.dummy)
            this.dummy.coords = [
                rotate(this.dummy.angle, this.dummy.cx, this.dummy.cy, this.dummy.x, this.dummy.y),
                rotate(this.dummy.angle, this.dummy.cx, this.dummy.cy, this.dummy.x + this.dummy.width, this.dummy.y),
                rotate(this.dummy.angle, this.dummy.cx, this.dummy.cy, this.dummy.x + this.dummy.width, this.dummy.y + this.dummy.height),
                rotate(this.dummy.angle, this.dummy.cx, this.dummy.cy, this.dummy.x, this.dummy.y + this.dummy.height)
            ]
        }, 
        (o) => {
            o.height *= - 1
            o.y *= -1
            // let path2 = `(${o.x}, ${o.y})--(${o.x + o.width}, ${o.y})--(${o.x + o.width}, ${o.y + o.height})--(${o.x}, ${o.y + o.height})--cycle`
            let path = `(${o.coords[0][0]}, ${-o.coords[0][1]})--(${o.coords[1][0]}, ${-o.coords[1][1]})--(${o.coords[2][0]}, ${-o.coords[2][1]})--(${o.coords[3][0]}, ${-o.coords[3][1]})--cycle` 
            o.y *= -1
            o.height *= - 1
            if (o.roundness) {
                // TODO
            } else {
                this.dummy += `draw(${path}, ${this.getPen(o)});\n`
                //  this.dummy += `draw(${path2}, black);\n`
            }
            path = null
        },
        (ctx, o) => {
                ctx.strokeColor = "red"
                ctx.fillStyle = "red"
                // ctx.strokeRect(o.x, o.y, o.width, o.height)
                polygon(ctx, "green", 2, o.coords, 0, 0, [0, 0], 1) 
                // ctx.fillRect(o.cx - 10, o.cy - 10, 20, 20)
            }
        )
        this.addType("ellipse", (e) => {
            this.default(e)
        },
        (o) => {
            o.cy *= -1
            o.angle *= -1
            this.dummy = `draw(shift(${o.cx}, ${o.cy}) * rotate(${Math.floor(o.angle*180/Math.PI)}) * ellipse((0, 0), ${o.width/2}, ${o.height/2}), ${this.getPen(o)});`
            // this.dummy += `\ndot((${o.cx}, ${o.cy})); \n`
            o.cy *= -1
            o.angle *= -1
        },
        (ctx, e) => {
            ctx.beginPath()
            ctx.ellipse(e.cx, e.cy, e.width/2, e.height/2, e.angle, 0, 2 * Math.PI)
            ctx.stroke()
            ctx.closePath()
        }
        )
        this.addType("line", (e) => {
            this.default(e)
            this.dummy.cy = this.dummy.y - this.dummy.height/2
            this.dummy.points = Array.from(e.points, x => rotate(this.dummy.angle, this.dummy.width/2, -this.dummy.height/2, x[0], x[1]) )
        }, 
        (o) => {
            // let testy = o.points.reduce((total, coords) => {return total + `(${Math.round(coords[0] + o.x)}, ${-Math.round(coords[1] + o.y)})--` })
            // testy = testy.substring(3, testy.length) + "cycle"
            let testy = o.points.map(pt => `(${Math.round(pt[0] + o.x)}, ${-Math.round(pt[1] + o.y)})`).join("--");
            this.dummy = `draw(${testy}, ${this.getPen(o)});\n`
        },
        (ctx, e) => {
            // x, y bottom left
            polygon(ctx, e.strokeColor, e.strokeWidth, e.points, 0, 0, [e.x, e.y], 1)
            // ctx.fillRect(e.cx, e.cy, 10, 10)
            // ctx.strokeRect(e.x, e.y - e.height, e.width, e.height)
        }
        )
    }

    getPen(o) {return `${o.strokeColor}+linewidth(${o.strokeWidth})${(o.strokeStyle) ? "+Dashed" : ""}`}

    default(e) {
        console.log(e)
        this.dummy.type = e.type
        this.dummy.strokeColor = hexToRgb(e.strokeColor)
        this.dummy.strokeWidth = e.strokeWidth
        this.dummy.strokeStyle = (e.strokeStyle === "dashed")
        this.dummy.x = Math.round(e.x)
        this.dummy.y = Math.round(e.y)
        this.dummy.width = Math.round(e.width)
        this.dummy.height = Math.round(e.height)
        this.dummy.angle = Math.round(e.angle * 100)/100
        this.dummy.cx = this.dummy.x + this.dummy.width/2
        this.dummy.cy = this.dummy.y + this.dummy.height/2
        this.dummy.cos = Math.cos(this.dummy.angle)
        this.dummy.sin = Math.sin(this.dummy.angle)
        this.dummy.opacity = e.opacity/100
        this.dummy.roundness = (e.roundness != null)
    }

    addType(type, callback, asy, canvasDraw) {this.types[type] = {parse: callback, asymptote: asy, canvasDraw: canvasDraw}}

    parse(data) {
        data.elements.forEach(element => {
            if (this.types.hasOwnProperty(element.type)) {
                this.dummy = {}
                this.types[element.type].parse.call(this, element)
                this.elements.push(this.dummy)
                this.dummy = null
            } else {
                console.log(`${element.type} not recognized`)
            }
        });
    } 

    toAsymptote() {
        this.text += "/* Generated by Cloud's Excalidraw to Asymptote */\n"
        this.elements.forEach(element => {
            this.dummy = ""
            this.types[element.type].asymptote(element)
            this.text += this.dummy
        })
        // import roundedpath;
        // draw(roundedpath((0,0)--(0,10)--(23,10)--(23, 0)--cycle, 4), red);
    }

    draw(ctx) {
        this.elements.forEach(e => {
            this.types[e.type].canvasDraw(ctx, e)
        })
    }
}

function test () {
    let context = canvas.getContext("2d")
    let parser = new ExcalidrawToAsy()
    parser.init()
    bruh.onchange = () => {
        if (bruh.value.trim() === "") {return;}
        parser.text = ""
        parser.elements = []
        parser.parse(JSON.parse(bruh.value))
        console.log(parser.elements)
        parser.toAsymptote()
        console.log(parser.text)
        parser.draw(context)
    }


}

test()

</script>
</body>
</html>
